{"ast":null,"code":"let _Symbol$toStringTag;\n\nimport Prop from \"./Prop.js\";\nimport Assert from \"./Assert.js\";\n_Symbol$toStringTag = Symbol.toStringTag;\n\nclass Klass {\n  constructor(name) {\n    this._name = Klass.assertName(name);\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  get short() {\n    return this._name.charAt(0).toLowerCase();\n  }\n\n  get [_Symbol$toStringTag]() {\n    return this._name;\n  }\n\n  static get Names() {\n    return Names;\n  }\n\n  static get Attack() {\n    return Names.Attack;\n  }\n\n  static get Colonization() {\n    return Names.Colonization;\n  }\n\n  static get Production() {\n    return Names.Production;\n  }\n\n  static get Science() {\n    return Names.Science;\n  }\n\n  static assert(sample) {\n    if (sample instanceof Klass) {\n      return sample;\n    }\n\n    if (typeof sample === 'string') {\n      return Klass.fromString(sample);\n    }\n\n    Assert.error('not a Klass', sample);\n  }\n\n  static fromString(name) {\n    return new Klass(name);\n  }\n\n  static assertName(name) {\n    if (typeof name !== 'string') {\n      Assert.error('wrong Klass given', name);\n    }\n\n    name = name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();\n\n    if (Letters[name]) {\n      return Letters[name];\n    }\n\n    if (Names[name]) {\n      return Names[name];\n    }\n\n    Assert.error('wrong Klass name', name);\n  }\n\n}\n\nKlass._letters = {};\nconst Names = Object.freeze({\n  [Prop.Attack]: Prop.Attack,\n  [Prop.Colonization]: Prop.Colonization,\n  [Prop.Science]: Prop.Science,\n  [Prop.Production]: Prop.Production\n}); // TODO convert automatically\n\nconst Letters = Object.freeze({\n  A: Prop.Attack,\n  C: Prop.Colonization,\n  S: Prop.Science,\n  P: Prop.Production\n});\nexport default Klass;","map":{"version":3,"sources":["C:/Users/a_kyl/Documents/GitHub/8bitgalaxy/src/Model/Klass.js"],"names":["Prop","Assert","Symbol","toStringTag","Klass","constructor","name","_name","assertName","short","charAt","toLowerCase","Names","Attack","Colonization","Production","Science","assert","sample","fromString","error","toUpperCase","slice","Letters","_letters","Object","freeze","A","C","S","P"],"mappings":";;AAAA,OAAOA,IAAP,MAAiB,WAAjB;AACA,OAAOC,MAAP,MAAmB,aAAnB;sBASOC,MAAM,CAACC,W;;AAPd,MAAMC,KAAN,CAAY;AACVC,EAAAA,WAAW,CAACC,IAAD,EAAO;AAChB,SAAKC,KAAL,GAAaH,KAAK,CAACI,UAAN,CAAiBF,IAAjB,CAAb;AACD;;AAEO,MAAJA,IAAI,GAAI;AAAE,WAAO,KAAKC,KAAZ;AAAoB;;AACzB,MAALE,KAAK,GAAG;AAAE,WAAO,KAAKF,KAAL,CAAWG,MAAX,CAAkB,CAAlB,EAAqBC,WAArB,EAAP;AAA4C;;AAC1D,8BAA2B;AAAE,WAAO,KAAKJ,KAAZ;AAAoB;;AAEjC,aAALK,KAAK,GAAc;AAAE,WAAOA,KAAP;AAAe;;AAC9B,aAANC,MAAM,GAAa;AAAE,WAAOD,KAAK,CAACC,MAAb;AAAsB;;AAC/B,aAAZC,YAAY,GAAO;AAAE,WAAOF,KAAK,CAACE,YAAb;AAA4B;;AACvC,aAAVC,UAAU,GAAS;AAAE,WAAOH,KAAK,CAACG,UAAb;AAA0B;;AACxC,aAAPC,OAAO,GAAY;AAAE,WAAOJ,KAAK,CAACI,OAAb;AAAuB;;AAE1C,SAANC,MAAM,CAACC,MAAD,EAAS;AACpB,QAAIA,MAAM,YAAYd,KAAtB,EAA8B;AAC5B,aAAOc,MAAP;AACD;;AACD,QAAI,OAAOA,MAAP,KAAmB,QAAvB,EAAiC;AAC/B,aAAOd,KAAK,CAACe,UAAN,CAAiBD,MAAjB,CAAP;AACD;;AACDjB,IAAAA,MAAM,CAACmB,KAAP,CAAa,aAAb,EAA4BF,MAA5B;AACD;;AAEgB,SAAVC,UAAU,CAACb,IAAD,EAAO;AAAE,WAAO,IAAIF,KAAJ,CAAUE,IAAV,CAAP;AAAyB;;AAIlC,SAAVE,UAAU,CAACF,IAAD,EAAO;AACtB,QAAI,OAAOA,IAAP,KAAiB,QAArB,EAA+B;AAC7BL,MAAAA,MAAM,CAACmB,KAAP,CAAa,mBAAb,EAAkCd,IAAlC;AACD;;AACDA,IAAAA,IAAI,GAAGA,IAAI,CAACI,MAAL,CAAY,CAAZ,EAAeW,WAAf,KAA+Bf,IAAI,CAACgB,KAAL,CAAW,CAAX,EAAcX,WAAd,EAAtC;;AACA,QAAIY,OAAO,CAACjB,IAAD,CAAX,EAAmB;AACjB,aAAOiB,OAAO,CAACjB,IAAD,CAAd;AACD;;AACD,QAAIM,KAAK,CAACN,IAAD,CAAT,EAAiB;AACf,aAAOM,KAAK,CAACN,IAAD,CAAZ;AACD;;AACDL,IAAAA,MAAM,CAACmB,KAAP,CAAa,kBAAb,EAAiCd,IAAjC;AACD;;AAzCS;;AAANF,K,CA2BGoB,Q,GAAW,E;AAiBpB,MAAMZ,KAAK,GAAGa,MAAM,CAACC,MAAP,CAAc;AAC1B,GAAC1B,IAAI,CAACa,MAAN,GAAsBb,IAAI,CAACa,MADD;AAE1B,GAACb,IAAI,CAACc,YAAN,GAAsBd,IAAI,CAACc,YAFD;AAG1B,GAACd,IAAI,CAACgB,OAAN,GAAsBhB,IAAI,CAACgB,OAHD;AAI1B,GAAChB,IAAI,CAACe,UAAN,GAAsBf,IAAI,CAACe;AAJD,CAAd,CAAd,C,CAOA;;AACA,MAAMQ,OAAO,GAAGE,MAAM,CAACC,MAAP,CAAc;AAC5BC,EAAAA,CAAC,EAAqB3B,IAAI,CAACa,MADC;AAE5Be,EAAAA,CAAC,EAAqB5B,IAAI,CAACc,YAFC;AAG5Be,EAAAA,CAAC,EAAqB7B,IAAI,CAACgB,OAHC;AAI5Bc,EAAAA,CAAC,EAAqB9B,IAAI,CAACe;AAJC,CAAd,CAAhB;AAOA,eAAeX,KAAf","sourcesContent":["import Prop from \"./Prop.js\";\r\nimport Assert from \"./Assert.js\";\r\n\r\nclass Klass {\r\n  constructor(name) {\r\n    this._name = Klass.assertName(name);\r\n  }\r\n\r\n  get name()  { return this._name; }\r\n  get short() { return this._name.charAt(0).toLowerCase(); }\r\n  get [Symbol.toStringTag]() { return this._name; }\r\n\r\n  static get Names()            { return Names; }\r\n  static get Attack()           { return Names.Attack; }\r\n  static get Colonization()     { return Names.Colonization; }\r\n  static get Production()       { return Names.Production; }\r\n  static get Science()          { return Names.Science; }\r\n\r\n  static assert(sample) {\r\n    if (sample instanceof(Klass)) {\r\n      return sample;\r\n    }\r\n    if (typeof(sample) === 'string') {\r\n      return Klass.fromString(sample);\r\n    }\r\n    Assert.error('not a Klass', sample);\r\n  }\r\n\r\n  static fromString(name) { return new Klass(name); }\r\n\r\n  static _letters = {};\r\n\r\n  static assertName(name) {\r\n    if (typeof(name) !== 'string') {\r\n      Assert.error('wrong Klass given', name);\r\n    }\r\n    name = name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();\r\n    if (Letters[name]) {\r\n      return Letters[name]\r\n    }\r\n    if (Names[name]) {\r\n      return Names[name];\r\n    }\r\n    Assert.error('wrong Klass name', name);\r\n  }\r\n}\r\n\r\nconst Names = Object.freeze({\r\n  [Prop.Attack]:        Prop.Attack,\r\n  [Prop.Colonization]:  Prop.Colonization,\r\n  [Prop.Science]:       Prop.Science,\r\n  [Prop.Production]:    Prop.Production,\r\n})\r\n\r\n// TODO convert automatically\r\nconst Letters = Object.freeze({\r\n  A:                    Prop.Attack,\r\n  C:                    Prop.Colonization,\r\n  S:                    Prop.Science,\r\n  P:                    Prop.Production,\r\n})\r\n\r\nexport default Klass;\r\n"]},"metadata":{},"sourceType":"module"}